"""Provide an abstract structure for fixing model instances."""


# Automatically generated by dev_scripts/codegen/generate_abstract_fixing.py.
# Do NOT edit or append!


from aas_core3 import types as aas_types

from aas_core3_0_testgen import common


class AbstractHandyman(aas_types.AbstractVisitorWithContext[common.CanHash]):
    """Fix instances recursively on best-effort basis."""

    def _fix_extension(
        self, that: aas_types.Extension, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_administrative_information(
        self, that: aas_types.AdministrativeInformation, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_qualifier(
        self, that: aas_types.Qualifier, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_asset_administration_shell(
        self, that: aas_types.AssetAdministrationShell, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_asset_information(
        self, that: aas_types.AssetInformation, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_resource(
        self, that: aas_types.Resource, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_specific_asset_id(
        self, that: aas_types.SpecificAssetID, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_submodel(
        self, that: aas_types.Submodel, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_relationship_element(
        self, that: aas_types.RelationshipElement, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_submodel_element_list(
        self, that: aas_types.SubmodelElementList, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_submodel_element_collection(
        self, that: aas_types.SubmodelElementCollection, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_property(
        self, that: aas_types.Property, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_multi_language_property(
        self, that: aas_types.MultiLanguageProperty, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_range(self, that: aas_types.Range, path_hash: common.CanHash) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_reference_element(
        self, that: aas_types.ReferenceElement, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_blob(self, that: aas_types.Blob, path_hash: common.CanHash) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_file(self, that: aas_types.File, path_hash: common.CanHash) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_annotated_relationship_element(
        self, that: aas_types.AnnotatedRelationshipElement, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_entity(self, that: aas_types.Entity, path_hash: common.CanHash) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_event_payload(
        self, that: aas_types.EventPayload, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_basic_event_element(
        self, that: aas_types.BasicEventElement, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_operation(
        self, that: aas_types.Operation, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_operation_variable(
        self, that: aas_types.OperationVariable, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_capability(
        self, that: aas_types.Capability, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_concept_description(
        self, that: aas_types.ConceptDescription, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_reference(
        self, that: aas_types.Reference, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_key(self, that: aas_types.Key, path_hash: common.CanHash) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_lang_string_name_type(
        self, that: aas_types.LangStringNameType, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_lang_string_text_type(
        self, that: aas_types.LangStringTextType, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_environment(
        self, that: aas_types.Environment, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_embedded_data_specification(
        self, that: aas_types.EmbeddedDataSpecification, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_level_type(
        self, that: aas_types.LevelType, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_value_reference_pair(
        self, that: aas_types.ValueReferencePair, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_value_list(
        self, that: aas_types.ValueList, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_lang_string_preferred_name_type_iec_61360(
        self,
        that: aas_types.LangStringPreferredNameTypeIEC61360,
        path_hash: common.CanHash,
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_lang_string_short_name_type_iec_61360(
        self, that: aas_types.LangStringShortNameTypeIEC61360, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_lang_string_definition_type_iec_61360(
        self,
        that: aas_types.LangStringDefinitionTypeIEC61360,
        path_hash: common.CanHash,
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def _fix_data_specification_iec_61360(
        self, that: aas_types.DataSpecificationIEC61360, path_hash: common.CanHash
    ) -> None:
        """
        Fix ``that`` instance in-place.

        Do *not* recurse into children. This is handled by ``visit_**`` methods since
        we have to couple the path hash and property names.
        """
        # Intentionally empty, to be overridden
        return

    def visit_extension_with_context(
        self, that: aas_types.Extension, context: common.CanHash
    ) -> None:
        self._fix_extension(that, context)

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.refers_to is not None:
            hash_for_refers_to = common.hash_path(context, "refers_to")
            for i, item_of_refers_to in enumerate(that.refers_to):
                self.visit_with_context(
                    item_of_refers_to, common.hash_path(hash_for_refers_to, i)
                )

    def visit_administrative_information_with_context(
        self, that: aas_types.AdministrativeInformation, context: common.CanHash
    ) -> None:
        self._fix_administrative_information(that, context)

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.creator is not None:
            self.visit_with_context(that.creator, common.hash_path(context, "creator"))

    def visit_qualifier_with_context(
        self, that: aas_types.Qualifier, context: common.CanHash
    ) -> None:
        self._fix_qualifier(that, context)

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.value_id is not None:
            self.visit_with_context(
                that.value_id, common.hash_path(context, "value_id")
            )

    def visit_asset_administration_shell_with_context(
        self, that: aas_types.AssetAdministrationShell, context: common.CanHash
    ) -> None:
        self._fix_asset_administration_shell(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.administration is not None:
            self.visit_with_context(
                that.administration, common.hash_path(context, "administration")
            )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.derived_from is not None:
            self.visit_with_context(
                that.derived_from, common.hash_path(context, "derived_from")
            )

        self.visit_with_context(
            that.asset_information, common.hash_path(context, "asset_information")
        )

        if that.submodels is not None:
            hash_for_submodels = common.hash_path(context, "submodels")
            for i, item_of_submodels in enumerate(that.submodels):
                self.visit_with_context(
                    item_of_submodels, common.hash_path(hash_for_submodels, i)
                )

    def visit_asset_information_with_context(
        self, that: aas_types.AssetInformation, context: common.CanHash
    ) -> None:
        self._fix_asset_information(that, context)

        if that.specific_asset_ids is not None:
            hash_for_specific_asset_ids = common.hash_path(
                context, "specific_asset_ids"
            )
            for i, item_of_specific_asset_ids in enumerate(that.specific_asset_ids):
                self.visit_with_context(
                    item_of_specific_asset_ids,
                    common.hash_path(hash_for_specific_asset_ids, i),
                )

        if that.default_thumbnail is not None:
            self.visit_with_context(
                that.default_thumbnail, common.hash_path(context, "default_thumbnail")
            )

    def visit_resource_with_context(
        self, that: aas_types.Resource, context: common.CanHash
    ) -> None:
        self._fix_resource(that, context)

    def visit_specific_asset_id_with_context(
        self, that: aas_types.SpecificAssetID, context: common.CanHash
    ) -> None:
        self._fix_specific_asset_id(that, context)

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.external_subject_id is not None:
            self.visit_with_context(
                that.external_subject_id,
                common.hash_path(context, "external_subject_id"),
            )

    def visit_submodel_with_context(
        self, that: aas_types.Submodel, context: common.CanHash
    ) -> None:
        self._fix_submodel(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.administration is not None:
            self.visit_with_context(
                that.administration, common.hash_path(context, "administration")
            )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.submodel_elements is not None:
            hash_for_submodel_elements = common.hash_path(context, "submodel_elements")
            for i, item_of_submodel_elements in enumerate(that.submodel_elements):
                self.visit_with_context(
                    item_of_submodel_elements,
                    common.hash_path(hash_for_submodel_elements, i),
                )

    def visit_relationship_element_with_context(
        self, that: aas_types.RelationshipElement, context: common.CanHash
    ) -> None:
        self._fix_relationship_element(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        self.visit_with_context(that.first, common.hash_path(context, "first"))

        self.visit_with_context(that.second, common.hash_path(context, "second"))

    def visit_submodel_element_list_with_context(
        self, that: aas_types.SubmodelElementList, context: common.CanHash
    ) -> None:
        self._fix_submodel_element_list(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.semantic_id_list_element is not None:
            self.visit_with_context(
                that.semantic_id_list_element,
                common.hash_path(context, "semantic_id_list_element"),
            )

        if that.value is not None:
            hash_for_value = common.hash_path(context, "value")
            for i, item_of_value in enumerate(that.value):
                self.visit_with_context(
                    item_of_value, common.hash_path(hash_for_value, i)
                )

    def visit_submodel_element_collection_with_context(
        self, that: aas_types.SubmodelElementCollection, context: common.CanHash
    ) -> None:
        self._fix_submodel_element_collection(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.value is not None:
            hash_for_value = common.hash_path(context, "value")
            for i, item_of_value in enumerate(that.value):
                self.visit_with_context(
                    item_of_value, common.hash_path(hash_for_value, i)
                )

    def visit_property_with_context(
        self, that: aas_types.Property, context: common.CanHash
    ) -> None:
        self._fix_property(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.value_id is not None:
            self.visit_with_context(
                that.value_id, common.hash_path(context, "value_id")
            )

    def visit_multi_language_property_with_context(
        self, that: aas_types.MultiLanguageProperty, context: common.CanHash
    ) -> None:
        self._fix_multi_language_property(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.value is not None:
            hash_for_value = common.hash_path(context, "value")
            for i, item_of_value in enumerate(that.value):
                self.visit_with_context(
                    item_of_value, common.hash_path(hash_for_value, i)
                )

        if that.value_id is not None:
            self.visit_with_context(
                that.value_id, common.hash_path(context, "value_id")
            )

    def visit_range_with_context(
        self, that: aas_types.Range, context: common.CanHash
    ) -> None:
        self._fix_range(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

    def visit_reference_element_with_context(
        self, that: aas_types.ReferenceElement, context: common.CanHash
    ) -> None:
        self._fix_reference_element(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.value is not None:
            self.visit_with_context(that.value, common.hash_path(context, "value"))

    def visit_blob_with_context(
        self, that: aas_types.Blob, context: common.CanHash
    ) -> None:
        self._fix_blob(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

    def visit_file_with_context(
        self, that: aas_types.File, context: common.CanHash
    ) -> None:
        self._fix_file(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

    def visit_annotated_relationship_element_with_context(
        self, that: aas_types.AnnotatedRelationshipElement, context: common.CanHash
    ) -> None:
        self._fix_annotated_relationship_element(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        self.visit_with_context(that.first, common.hash_path(context, "first"))

        self.visit_with_context(that.second, common.hash_path(context, "second"))

        if that.annotations is not None:
            hash_for_annotations = common.hash_path(context, "annotations")
            for i, item_of_annotations in enumerate(that.annotations):
                self.visit_with_context(
                    item_of_annotations, common.hash_path(hash_for_annotations, i)
                )

    def visit_entity_with_context(
        self, that: aas_types.Entity, context: common.CanHash
    ) -> None:
        self._fix_entity(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.statements is not None:
            hash_for_statements = common.hash_path(context, "statements")
            for i, item_of_statements in enumerate(that.statements):
                self.visit_with_context(
                    item_of_statements, common.hash_path(hash_for_statements, i)
                )

        if that.specific_asset_ids is not None:
            hash_for_specific_asset_ids = common.hash_path(
                context, "specific_asset_ids"
            )
            for i, item_of_specific_asset_ids in enumerate(that.specific_asset_ids):
                self.visit_with_context(
                    item_of_specific_asset_ids,
                    common.hash_path(hash_for_specific_asset_ids, i),
                )

    def visit_event_payload_with_context(
        self, that: aas_types.EventPayload, context: common.CanHash
    ) -> None:
        self._fix_event_payload(that, context)

        self.visit_with_context(that.source, common.hash_path(context, "source"))

        if that.source_semantic_id is not None:
            self.visit_with_context(
                that.source_semantic_id, common.hash_path(context, "source_semantic_id")
            )

        self.visit_with_context(
            that.observable_reference, common.hash_path(context, "observable_reference")
        )

        if that.observable_semantic_id is not None:
            self.visit_with_context(
                that.observable_semantic_id,
                common.hash_path(context, "observable_semantic_id"),
            )

        if that.subject_id is not None:
            self.visit_with_context(
                that.subject_id, common.hash_path(context, "subject_id")
            )

    def visit_basic_event_element_with_context(
        self, that: aas_types.BasicEventElement, context: common.CanHash
    ) -> None:
        self._fix_basic_event_element(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        self.visit_with_context(that.observed, common.hash_path(context, "observed"))

        if that.message_broker is not None:
            self.visit_with_context(
                that.message_broker, common.hash_path(context, "message_broker")
            )

    def visit_operation_with_context(
        self, that: aas_types.Operation, context: common.CanHash
    ) -> None:
        self._fix_operation(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.input_variables is not None:
            hash_for_input_variables = common.hash_path(context, "input_variables")
            for i, item_of_input_variables in enumerate(that.input_variables):
                self.visit_with_context(
                    item_of_input_variables,
                    common.hash_path(hash_for_input_variables, i),
                )

        if that.output_variables is not None:
            hash_for_output_variables = common.hash_path(context, "output_variables")
            for i, item_of_output_variables in enumerate(that.output_variables):
                self.visit_with_context(
                    item_of_output_variables,
                    common.hash_path(hash_for_output_variables, i),
                )

        if that.inoutput_variables is not None:
            hash_for_inoutput_variables = common.hash_path(
                context, "inoutput_variables"
            )
            for i, item_of_inoutput_variables in enumerate(that.inoutput_variables):
                self.visit_with_context(
                    item_of_inoutput_variables,
                    common.hash_path(hash_for_inoutput_variables, i),
                )

    def visit_operation_variable_with_context(
        self, that: aas_types.OperationVariable, context: common.CanHash
    ) -> None:
        self._fix_operation_variable(that, context)

        self.visit_with_context(that.value, common.hash_path(context, "value"))

    def visit_capability_with_context(
        self, that: aas_types.Capability, context: common.CanHash
    ) -> None:
        self._fix_capability(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.semantic_id is not None:
            self.visit_with_context(
                that.semantic_id, common.hash_path(context, "semantic_id")
            )

        if that.supplemental_semantic_ids is not None:
            hash_for_supplemental_semantic_ids = common.hash_path(
                context, "supplemental_semantic_ids"
            )
            for i, item_of_supplemental_semantic_ids in enumerate(
                that.supplemental_semantic_ids
            ):
                self.visit_with_context(
                    item_of_supplemental_semantic_ids,
                    common.hash_path(hash_for_supplemental_semantic_ids, i),
                )

        if that.qualifiers is not None:
            hash_for_qualifiers = common.hash_path(context, "qualifiers")
            for i, item_of_qualifiers in enumerate(that.qualifiers):
                self.visit_with_context(
                    item_of_qualifiers, common.hash_path(hash_for_qualifiers, i)
                )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

    def visit_concept_description_with_context(
        self, that: aas_types.ConceptDescription, context: common.CanHash
    ) -> None:
        self._fix_concept_description(that, context)

        if that.extensions is not None:
            hash_for_extensions = common.hash_path(context, "extensions")
            for i, item_of_extensions in enumerate(that.extensions):
                self.visit_with_context(
                    item_of_extensions, common.hash_path(hash_for_extensions, i)
                )

        if that.display_name is not None:
            hash_for_display_name = common.hash_path(context, "display_name")
            for i, item_of_display_name in enumerate(that.display_name):
                self.visit_with_context(
                    item_of_display_name, common.hash_path(hash_for_display_name, i)
                )

        if that.description is not None:
            hash_for_description = common.hash_path(context, "description")
            for i, item_of_description in enumerate(that.description):
                self.visit_with_context(
                    item_of_description, common.hash_path(hash_for_description, i)
                )

        if that.administration is not None:
            self.visit_with_context(
                that.administration, common.hash_path(context, "administration")
            )

        if that.embedded_data_specifications is not None:
            hash_for_embedded_data_specifications = common.hash_path(
                context, "embedded_data_specifications"
            )
            for i, item_of_embedded_data_specifications in enumerate(
                that.embedded_data_specifications
            ):
                self.visit_with_context(
                    item_of_embedded_data_specifications,
                    common.hash_path(hash_for_embedded_data_specifications, i),
                )

        if that.is_case_of is not None:
            hash_for_is_case_of = common.hash_path(context, "is_case_of")
            for i, item_of_is_case_of in enumerate(that.is_case_of):
                self.visit_with_context(
                    item_of_is_case_of, common.hash_path(hash_for_is_case_of, i)
                )

    def visit_reference_with_context(
        self, that: aas_types.Reference, context: common.CanHash
    ) -> None:
        self._fix_reference(that, context)

        if that.referred_semantic_id is not None:
            self.visit_with_context(
                that.referred_semantic_id,
                common.hash_path(context, "referred_semantic_id"),
            )

        hash_for_keys = common.hash_path(context, "keys")
        for i, item_of_keys in enumerate(that.keys):
            self.visit_with_context(item_of_keys, common.hash_path(hash_for_keys, i))

    def visit_key_with_context(
        self, that: aas_types.Key, context: common.CanHash
    ) -> None:
        self._fix_key(that, context)

    def visit_lang_string_name_type_with_context(
        self, that: aas_types.LangStringNameType, context: common.CanHash
    ) -> None:
        self._fix_lang_string_name_type(that, context)

    def visit_lang_string_text_type_with_context(
        self, that: aas_types.LangStringTextType, context: common.CanHash
    ) -> None:
        self._fix_lang_string_text_type(that, context)

    def visit_environment_with_context(
        self, that: aas_types.Environment, context: common.CanHash
    ) -> None:
        self._fix_environment(that, context)

        if that.asset_administration_shells is not None:
            hash_for_asset_administration_shells = common.hash_path(
                context, "asset_administration_shells"
            )
            for i, item_of_asset_administration_shells in enumerate(
                that.asset_administration_shells
            ):
                self.visit_with_context(
                    item_of_asset_administration_shells,
                    common.hash_path(hash_for_asset_administration_shells, i),
                )

        if that.submodels is not None:
            hash_for_submodels = common.hash_path(context, "submodels")
            for i, item_of_submodels in enumerate(that.submodels):
                self.visit_with_context(
                    item_of_submodels, common.hash_path(hash_for_submodels, i)
                )

        if that.concept_descriptions is not None:
            hash_for_concept_descriptions = common.hash_path(
                context, "concept_descriptions"
            )
            for i, item_of_concept_descriptions in enumerate(that.concept_descriptions):
                self.visit_with_context(
                    item_of_concept_descriptions,
                    common.hash_path(hash_for_concept_descriptions, i),
                )

    def visit_embedded_data_specification_with_context(
        self, that: aas_types.EmbeddedDataSpecification, context: common.CanHash
    ) -> None:
        self._fix_embedded_data_specification(that, context)

        self.visit_with_context(
            that.data_specification, common.hash_path(context, "data_specification")
        )

        self.visit_with_context(
            that.data_specification_content,
            common.hash_path(context, "data_specification_content"),
        )

    def visit_level_type_with_context(
        self, that: aas_types.LevelType, context: common.CanHash
    ) -> None:
        self._fix_level_type(that, context)

    def visit_value_reference_pair_with_context(
        self, that: aas_types.ValueReferencePair, context: common.CanHash
    ) -> None:
        self._fix_value_reference_pair(that, context)

        self.visit_with_context(that.value_id, common.hash_path(context, "value_id"))

    def visit_value_list_with_context(
        self, that: aas_types.ValueList, context: common.CanHash
    ) -> None:
        self._fix_value_list(that, context)

        hash_for_value_reference_pairs = common.hash_path(
            context, "value_reference_pairs"
        )
        for i, item_of_value_reference_pairs in enumerate(that.value_reference_pairs):
            self.visit_with_context(
                item_of_value_reference_pairs,
                common.hash_path(hash_for_value_reference_pairs, i),
            )

    def visit_lang_string_preferred_name_type_iec_61360_with_context(
        self,
        that: aas_types.LangStringPreferredNameTypeIEC61360,
        context: common.CanHash,
    ) -> None:
        self._fix_lang_string_preferred_name_type_iec_61360(that, context)

    def visit_lang_string_short_name_type_iec_61360_with_context(
        self, that: aas_types.LangStringShortNameTypeIEC61360, context: common.CanHash
    ) -> None:
        self._fix_lang_string_short_name_type_iec_61360(that, context)

    def visit_lang_string_definition_type_iec_61360_with_context(
        self, that: aas_types.LangStringDefinitionTypeIEC61360, context: common.CanHash
    ) -> None:
        self._fix_lang_string_definition_type_iec_61360(that, context)

    def visit_data_specification_iec_61360_with_context(
        self, that: aas_types.DataSpecificationIEC61360, context: common.CanHash
    ) -> None:
        self._fix_data_specification_iec_61360(that, context)

        hash_for_preferred_name = common.hash_path(context, "preferred_name")
        for i, item_of_preferred_name in enumerate(that.preferred_name):
            self.visit_with_context(
                item_of_preferred_name, common.hash_path(hash_for_preferred_name, i)
            )

        if that.short_name is not None:
            hash_for_short_name = common.hash_path(context, "short_name")
            for i, item_of_short_name in enumerate(that.short_name):
                self.visit_with_context(
                    item_of_short_name, common.hash_path(hash_for_short_name, i)
                )

        if that.unit_id is not None:
            self.visit_with_context(that.unit_id, common.hash_path(context, "unit_id"))

        if that.definition is not None:
            hash_for_definition = common.hash_path(context, "definition")
            for i, item_of_definition in enumerate(that.definition):
                self.visit_with_context(
                    item_of_definition, common.hash_path(hash_for_definition, i)
                )

        if that.value_list is not None:
            self.visit_with_context(
                that.value_list, common.hash_path(context, "value_list")
            )

        if that.level_type is not None:
            self.visit_with_context(
                that.level_type, common.hash_path(context, "level_type")
            )


# Automatically generated by dev_scripts/codegen/generate_abstract_fixing.py.
# Do NOT edit or append!

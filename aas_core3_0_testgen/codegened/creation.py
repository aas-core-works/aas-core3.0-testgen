"""Create instances which satisfy the type constraints."""


# Automatically generated by dev_scripts/codegen/generate_creation.py.
# Do NOT edit or append!


# pylint: disable=line-too-long


from typing import Callable, Mapping, Sequence

from aas_core3_0_testgen import common
from aas_core3_0_testgen import primitiving
from aas_core3 import types as aas_types


def minimal_has_semantics(path_hash: common.CanHash) -> aas_types.HasSemantics:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Has_semantics"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasSemantics,
    )
    return instance


def minimal_extension(path_hash: common.CanHash) -> aas_types.Extension:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Extension(
        name=(
            primitiving.generate_str(
                common.hash_path(path_hash, "name"), min_len=1, max_len=128
            )
        )
    )


def minimal_has_extensions(path_hash: common.CanHash) -> aas_types.HasExtensions:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Has_extensions"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasExtensions,
    )
    return instance


def minimal_referable(path_hash: common.CanHash) -> aas_types.Referable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Referable"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.Referable,
    )
    return instance


def minimal_identifiable(path_hash: common.CanHash) -> aas_types.Identifiable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Identifiable"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.Identifiable,
    )
    return instance


def minimal_has_kind(path_hash: common.CanHash) -> aas_types.HasKind:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Has_kind"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasKind,
    )
    return instance


def minimal_has_data_specification(
    path_hash: common.CanHash,
) -> aas_types.HasDataSpecification:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS[
        "Has_data_specification"
    ]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasDataSpecification,
    )
    return instance


def minimal_administrative_information(
    path_hash: common.CanHash,
) -> aas_types.AdministrativeInformation:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AdministrativeInformation()


def minimal_qualifiable(path_hash: common.CanHash) -> aas_types.Qualifiable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Qualifiable"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.Qualifiable,
    )
    return instance


def minimal_qualifier(path_hash: common.CanHash) -> aas_types.Qualifier:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Qualifier(
        type=(
            primitiving.generate_str(
                common.hash_path(path_hash, "type"), min_len=1, max_len=128
            )
        ),
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        ),
    )


def minimal_asset_administration_shell(
    path_hash: common.CanHash,
) -> aas_types.AssetAdministrationShell:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AssetAdministrationShell(
        id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "ID"), min_len=1, max_len=2000
            )
        ),
        asset_information=(
            minimal_asset_information(common.hash_path(path_hash, "asset_information"))
        ),
    )


def minimal_asset_information(path_hash: common.CanHash) -> aas_types.AssetInformation:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AssetInformation(
        asset_kind=(
            primitiving.choose_value(
                common.hash_path(path_hash, "asset_kind"), list(aas_types.AssetKind)
            )
        )
    )


def minimal_resource(path_hash: common.CanHash) -> aas_types.Resource:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Resource(
        path=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "path"),
                "^file:(//((localhost|(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)))?/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?)$",
            )
        )
    )


def minimal_specific_asset_id(path_hash: common.CanHash) -> aas_types.SpecificAssetID:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.SpecificAssetID(
        name=(
            primitiving.generate_str(
                common.hash_path(path_hash, "name"), min_len=1, max_len=64
            )
        ),
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
    )


def minimal_submodel(path_hash: common.CanHash) -> aas_types.Submodel:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Submodel(
        id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "ID"), min_len=1, max_len=2000
            )
        )
    )


def minimal_submodel_element(path_hash: common.CanHash) -> aas_types.SubmodelElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Submodel_element"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.SubmodelElement,
    )
    return instance


def concrete_minimal_relationship_element(
    path_hash: common.CanHash,
) -> aas_types.RelationshipElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        You usually do not call this function directly. It will be dispatched
        to.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.RelationshipElement(
        first=(minimal_reference(common.hash_path(path_hash, "first"))),
        second=(minimal_reference(common.hash_path(path_hash, "second"))),
    )


def minimal_relationship_element(
    path_hash: common.CanHash,
) -> aas_types.RelationshipElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS[
        "Relationship_element"
    ]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.RelationshipElement,
    )
    return instance


def minimal_submodel_element_list(
    path_hash: common.CanHash,
) -> aas_types.SubmodelElementList:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.SubmodelElementList(
        type_value_list_element=(
            primitiving.choose_value(
                common.hash_path(path_hash, "type_value_list_element"),
                list(aas_types.AASSubmodelElements),
            )
        )
    )


def minimal_submodel_element_collection(
    path_hash: common.CanHash,
) -> aas_types.SubmodelElementCollection:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.SubmodelElementCollection()


def minimal_data_element(path_hash: common.CanHash) -> aas_types.DataElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Data_element"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.DataElement,
    )
    return instance


def minimal_property(path_hash: common.CanHash) -> aas_types.Property:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Property(
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        )
    )


def minimal_multi_language_property(
    path_hash: common.CanHash,
) -> aas_types.MultiLanguageProperty:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.MultiLanguageProperty()


def minimal_range(path_hash: common.CanHash) -> aas_types.Range:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Range(
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        )
    )


def minimal_reference_element(path_hash: common.CanHash) -> aas_types.ReferenceElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ReferenceElement()


def minimal_blob(path_hash: common.CanHash) -> aas_types.Blob:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Blob(
        content_type=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "content_type"),
                "^([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+|\"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*\"))*$",
            )
        )
    )


def minimal_file(path_hash: common.CanHash) -> aas_types.File:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.File(
        content_type=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "content_type"),
                "^([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+|\"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*\"))*$",
            )
        )
    )


def minimal_annotated_relationship_element(
    path_hash: common.CanHash,
) -> aas_types.AnnotatedRelationshipElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AnnotatedRelationshipElement(
        first=(minimal_reference(common.hash_path(path_hash, "first"))),
        second=(minimal_reference(common.hash_path(path_hash, "second"))),
    )


def minimal_entity(path_hash: common.CanHash) -> aas_types.Entity:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Entity(
        entity_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "entity_type"), list(aas_types.EntityType)
            )
        )
    )


def minimal_event_payload(path_hash: common.CanHash) -> aas_types.EventPayload:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.EventPayload(
        source=(minimal_reference(common.hash_path(path_hash, "source"))),
        observable_reference=(
            minimal_reference(common.hash_path(path_hash, "observable_reference"))
        ),
        time_stamp=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "time_stamp"),
                "^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|\\+00:00|-00:00)$",
            )
        ),
    )


def minimal_event_element(path_hash: common.CanHash) -> aas_types.EventElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS["Event_element"]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.EventElement,
    )
    return instance


def minimal_basic_event_element(
    path_hash: common.CanHash,
) -> aas_types.BasicEventElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.BasicEventElement(
        observed=(minimal_reference(common.hash_path(path_hash, "observed"))),
        direction=(
            primitiving.choose_value(
                common.hash_path(path_hash, "direction"), list(aas_types.Direction)
            )
        ),
        state=(
            primitiving.choose_value(
                common.hash_path(path_hash, "state"), list(aas_types.StateOfEvent)
            )
        ),
    )


def minimal_operation(path_hash: common.CanHash) -> aas_types.Operation:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Operation()


def minimal_operation_variable(
    path_hash: common.CanHash,
) -> aas_types.OperationVariable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.OperationVariable(
        value=(minimal_submodel_element(common.hash_path(path_hash, "value")))
    )


def minimal_capability(path_hash: common.CanHash) -> aas_types.Capability:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Capability()


def minimal_concept_description(
    path_hash: common.CanHash,
) -> aas_types.ConceptDescription:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ConceptDescription(
        id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "ID"), min_len=1, max_len=2000
            )
        )
    )


def minimal_reference(path_hash: common.CanHash) -> aas_types.Reference:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Reference(
        type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "type"), list(aas_types.ReferenceTypes)
            )
        ),
        keys=([minimal_key(common.hash_path(path_hash, "keys"))]),
    )


def minimal_key(path_hash: common.CanHash) -> aas_types.Key:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Key(
        type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "type"), list(aas_types.KeyTypes)
            )
        ),
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
    )


def minimal_abstract_lang_string(
    path_hash: common.CanHash,
) -> aas_types.AbstractLangString:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS[
        "Abstract_lang_string"
    ]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.AbstractLangString,
    )
    return instance


def minimal_lang_string_name_type(
    path_hash: common.CanHash,
) -> aas_types.LangStringNameType:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringNameType(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=128
            )
        ),
    )


def minimal_lang_string_text_type(
    path_hash: common.CanHash,
) -> aas_types.LangStringTextType:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringTextType(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=1023
            )
        ),
    )


def minimal_environment(path_hash: common.CanHash) -> aas_types.Environment:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Environment()


def minimal_data_specification_content(
    path_hash: common.CanHash,
) -> aas_types.DataSpecificationContent:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_minimal_functions = _CLASS_NAME_TO_CONCRETE_MINIMALS[
        "Data_specification_content"
    ]
    concrete_minimal_function = concrete_minimal_functions[
        number % len(concrete_minimal_functions)
    ]
    instance = concrete_minimal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.DataSpecificationContent,
    )
    return instance


def minimal_embedded_data_specification(
    path_hash: common.CanHash,
) -> aas_types.EmbeddedDataSpecification:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.EmbeddedDataSpecification(
        data_specification=(
            minimal_reference(common.hash_path(path_hash, "data_specification"))
        ),
        data_specification_content=(
            minimal_data_specification_content(
                common.hash_path(path_hash, "data_specification_content")
            )
        ),
    )


def minimal_level_type(path_hash: common.CanHash) -> aas_types.LevelType:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LevelType(
        min=(primitiving.generate_bool(common.hash_path(path_hash, "min"))),
        nom=(primitiving.generate_bool(common.hash_path(path_hash, "nom"))),
        typ=(primitiving.generate_bool(common.hash_path(path_hash, "typ"))),
        max=(primitiving.generate_bool(common.hash_path(path_hash, "max"))),
    )


def minimal_value_reference_pair(
    path_hash: common.CanHash,
) -> aas_types.ValueReferencePair:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ValueReferencePair(
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
        value_id=(minimal_reference(common.hash_path(path_hash, "value_ID"))),
    )


def minimal_value_list(path_hash: common.CanHash) -> aas_types.ValueList:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ValueList(
        value_reference_pairs=(
            [
                minimal_value_reference_pair(
                    common.hash_path(path_hash, "value_reference_pairs")
                )
            ]
        )
    )


def minimal_lang_string_preferred_name_type_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.LangStringPreferredNameTypeIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringPreferredNameTypeIEC61360(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=255
            )
        ),
    )


def minimal_lang_string_short_name_type_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.LangStringShortNameTypeIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringShortNameTypeIEC61360(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=18
            )
        ),
    )


def minimal_lang_string_definition_type_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.LangStringDefinitionTypeIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringDefinitionTypeIEC61360(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=1023
            )
        ),
    )


def minimal_data_specification_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.DataSpecificationIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.DataSpecificationIEC61360(
        preferred_name=(
            [
                minimal_lang_string_preferred_name_type_iec_61360(
                    common.hash_path(path_hash, "preferred_name")
                )
            ]
        )
    )


_CLASS_NAME_TO_CONCRETE_MINIMALS = {
    "Has_semantics": [
        minimal_relationship_element,
        minimal_annotated_relationship_element,
        minimal_basic_event_element,
        minimal_blob,
        minimal_capability,
        minimal_entity,
        minimal_extension,
        minimal_file,
        minimal_multi_language_property,
        minimal_operation,
        minimal_property,
        minimal_qualifier,
        minimal_range,
        minimal_reference_element,
        minimal_specific_asset_id,
        minimal_submodel,
        minimal_submodel_element_collection,
        minimal_submodel_element_list,
    ],
    "Has_extensions": [
        minimal_relationship_element,
        minimal_annotated_relationship_element,
        minimal_asset_administration_shell,
        minimal_basic_event_element,
        minimal_blob,
        minimal_capability,
        minimal_concept_description,
        minimal_entity,
        minimal_file,
        minimal_multi_language_property,
        minimal_operation,
        minimal_property,
        minimal_range,
        minimal_reference_element,
        minimal_submodel,
        minimal_submodel_element_collection,
        minimal_submodel_element_list,
    ],
    "Referable": [
        minimal_relationship_element,
        minimal_annotated_relationship_element,
        minimal_asset_administration_shell,
        minimal_basic_event_element,
        minimal_blob,
        minimal_capability,
        minimal_concept_description,
        minimal_entity,
        minimal_file,
        minimal_multi_language_property,
        minimal_operation,
        minimal_property,
        minimal_range,
        minimal_reference_element,
        minimal_submodel,
        minimal_submodel_element_collection,
        minimal_submodel_element_list,
    ],
    "Identifiable": [
        minimal_asset_administration_shell,
        minimal_concept_description,
        minimal_submodel,
    ],
    "Has_kind": [minimal_submodel],
    "Has_data_specification": [
        minimal_administrative_information,
        minimal_relationship_element,
        minimal_annotated_relationship_element,
        minimal_asset_administration_shell,
        minimal_basic_event_element,
        minimal_blob,
        minimal_capability,
        minimal_concept_description,
        minimal_entity,
        minimal_file,
        minimal_multi_language_property,
        minimal_operation,
        minimal_property,
        minimal_range,
        minimal_reference_element,
        minimal_submodel,
        minimal_submodel_element_collection,
        minimal_submodel_element_list,
    ],
    "Qualifiable": [
        minimal_relationship_element,
        minimal_annotated_relationship_element,
        minimal_basic_event_element,
        minimal_blob,
        minimal_capability,
        minimal_entity,
        minimal_file,
        minimal_multi_language_property,
        minimal_operation,
        minimal_property,
        minimal_range,
        minimal_reference_element,
        minimal_submodel,
        minimal_submodel_element_collection,
        minimal_submodel_element_list,
    ],
    "Submodel_element": [
        minimal_relationship_element,
        minimal_annotated_relationship_element,
        minimal_basic_event_element,
        minimal_blob,
        minimal_capability,
        minimal_entity,
        minimal_file,
        minimal_multi_language_property,
        minimal_operation,
        minimal_property,
        minimal_range,
        minimal_reference_element,
        minimal_submodel_element_collection,
        minimal_submodel_element_list,
    ],
    "Relationship_element": [
        concrete_minimal_relationship_element,
        minimal_annotated_relationship_element,
    ],
    "Data_element": [
        minimal_blob,
        minimal_file,
        minimal_multi_language_property,
        minimal_property,
        minimal_range,
        minimal_reference_element,
    ],
    "Event_element": [minimal_basic_event_element],
    "Abstract_lang_string": [
        minimal_lang_string_definition_type_iec_61360,
        minimal_lang_string_name_type,
        minimal_lang_string_preferred_name_type_iec_61360,
        minimal_lang_string_short_name_type_iec_61360,
        minimal_lang_string_text_type,
    ],
    "Data_specification_content": [minimal_data_specification_iec_61360],
}  # type: Mapping[str, Sequence[Callable[[common.CanHash], aas_types.Class]]]


_CLASS_NAME_TO_EXACT_CONCRETE_MINIMAL = {
    "Extension": minimal_extension,
    "Administrative_information": minimal_administrative_information,
    "Qualifier": minimal_qualifier,
    "Asset_administration_shell": minimal_asset_administration_shell,
    "Asset_information": minimal_asset_information,
    "Resource": minimal_resource,
    "Specific_asset_ID": minimal_specific_asset_id,
    "Submodel": minimal_submodel,
    "Relationship_element": concrete_minimal_relationship_element,
    "Submodel_element_list": minimal_submodel_element_list,
    "Submodel_element_collection": minimal_submodel_element_collection,
    "Property": minimal_property,
    "Multi_language_property": minimal_multi_language_property,
    "Range": minimal_range,
    "Reference_element": minimal_reference_element,
    "Blob": minimal_blob,
    "File": minimal_file,
    "Annotated_relationship_element": minimal_annotated_relationship_element,
    "Entity": minimal_entity,
    "Event_payload": minimal_event_payload,
    "Basic_event_element": minimal_basic_event_element,
    "Operation": minimal_operation,
    "Operation_variable": minimal_operation_variable,
    "Capability": minimal_capability,
    "Concept_description": minimal_concept_description,
    "Reference": minimal_reference,
    "Key": minimal_key,
    "Lang_string_name_type": minimal_lang_string_name_type,
    "Lang_string_text_type": minimal_lang_string_text_type,
    "Environment": minimal_environment,
    "Embedded_data_specification": minimal_embedded_data_specification,
    "Level_type": minimal_level_type,
    "Value_reference_pair": minimal_value_reference_pair,
    "Value_list": minimal_value_list,
    "Lang_string_preferred_name_type_IEC_61360": minimal_lang_string_preferred_name_type_iec_61360,
    "Lang_string_short_name_type_IEC_61360": minimal_lang_string_short_name_type_iec_61360,
    "Lang_string_definition_type_IEC_61360": minimal_lang_string_definition_type_iec_61360,
    "Data_specification_IEC_61360": minimal_data_specification_iec_61360,
}


def exact_concrete_minimal(
    path_hash: common.CanHash, class_name: str
) -> aas_types.Class:
    """
    Create a minimal instance of exactly ``class_name``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    dispatch = _CLASS_NAME_TO_EXACT_CONCRETE_MINIMAL.get(class_name, None)
    if dispatch is None:
        raise KeyError(
            f"The class name {class_name!r} does not denote a concrete class "
            f"in the meta-model. Did you spell its name in the format of "
            f"aas-core-meta (*not* Python)?"
        )
    return dispatch(path_hash)


def maximal_has_semantics(path_hash: common.CanHash) -> aas_types.HasSemantics:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Has_semantics"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasSemantics,
    )
    return instance


def maximal_extension(path_hash: common.CanHash) -> aas_types.Extension:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Extension(
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        name=(
            primitiving.generate_str(
                common.hash_path(path_hash, "name"), min_len=1, max_len=128
            )
        ),
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        ),
        value=(primitiving.generate_str(common.hash_path(path_hash, "value"))),
        refers_to=([minimal_reference(common.hash_path(path_hash, "refers_to"))]),
    )


def maximal_has_extensions(path_hash: common.CanHash) -> aas_types.HasExtensions:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Has_extensions"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasExtensions,
    )
    return instance


def maximal_referable(path_hash: common.CanHash) -> aas_types.Referable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Referable"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.Referable,
    )
    return instance


def maximal_identifiable(path_hash: common.CanHash) -> aas_types.Identifiable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Identifiable"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.Identifiable,
    )
    return instance


def maximal_has_kind(path_hash: common.CanHash) -> aas_types.HasKind:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Has_kind"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasKind,
    )
    return instance


def maximal_has_data_specification(
    path_hash: common.CanHash,
) -> aas_types.HasDataSpecification:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS[
        "Has_data_specification"
    ]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.HasDataSpecification,
    )
    return instance


def maximal_administrative_information(
    path_hash: common.CanHash,
) -> aas_types.AdministrativeInformation:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AdministrativeInformation(
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        version=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "version"), "^(0|[1-9][0-9]*)$"
            )
        ),
        revision=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "revision"), "^(0|[1-9][0-9]*)$"
            )
        ),
        creator=(minimal_reference(common.hash_path(path_hash, "creator"))),
        template_id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "template_ID"), min_len=1, max_len=2000
            )
        ),
    )


def maximal_qualifiable(path_hash: common.CanHash) -> aas_types.Qualifiable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Qualifiable"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.Qualifiable,
    )
    return instance


def maximal_qualifier(path_hash: common.CanHash) -> aas_types.Qualifier:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Qualifier(
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        kind=(
            primitiving.choose_value(
                common.hash_path(path_hash, "kind"), list(aas_types.QualifierKind)
            )
        ),
        type=(
            primitiving.generate_str(
                common.hash_path(path_hash, "type"), min_len=1, max_len=128
            )
        ),
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        ),
        value=(primitiving.generate_str(common.hash_path(path_hash, "value"))),
        value_id=(minimal_reference(common.hash_path(path_hash, "value_ID"))),
    )


def maximal_asset_administration_shell(
    path_hash: common.CanHash,
) -> aas_types.AssetAdministrationShell:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AssetAdministrationShell(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        administration=(
            minimal_administrative_information(
                common.hash_path(path_hash, "administration")
            )
        ),
        id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "ID"), min_len=1, max_len=2000
            )
        ),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        derived_from=(minimal_reference(common.hash_path(path_hash, "derived_from"))),
        asset_information=(
            minimal_asset_information(common.hash_path(path_hash, "asset_information"))
        ),
        submodels=([minimal_reference(common.hash_path(path_hash, "submodels"))]),
    )


def maximal_asset_information(path_hash: common.CanHash) -> aas_types.AssetInformation:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AssetInformation(
        asset_kind=(
            primitiving.choose_value(
                common.hash_path(path_hash, "asset_kind"), list(aas_types.AssetKind)
            )
        ),
        global_asset_id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "global_asset_ID"), min_len=1, max_len=2000
            )
        ),
        specific_asset_ids=(
            [
                minimal_specific_asset_id(
                    common.hash_path(path_hash, "specific_asset_IDs")
                )
            ]
        ),
        asset_type=(
            primitiving.generate_str(
                common.hash_path(path_hash, "asset_type"), min_len=1, max_len=2000
            )
        ),
        default_thumbnail=(
            minimal_resource(common.hash_path(path_hash, "default_thumbnail"))
        ),
    )


def maximal_resource(path_hash: common.CanHash) -> aas_types.Resource:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Resource(
        path=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "path"),
                "^file:(//((localhost|(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)))?/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?)$",
            )
        ),
        content_type=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "content_type"),
                "^([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+|\"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*\"))*$",
            )
        ),
    )


def maximal_specific_asset_id(path_hash: common.CanHash) -> aas_types.SpecificAssetID:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.SpecificAssetID(
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        name=(
            primitiving.generate_str(
                common.hash_path(path_hash, "name"), min_len=1, max_len=64
            )
        ),
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
        external_subject_id=(
            minimal_reference(common.hash_path(path_hash, "external_subject_ID"))
        ),
    )


def maximal_submodel(path_hash: common.CanHash) -> aas_types.Submodel:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Submodel(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        administration=(
            minimal_administrative_information(
                common.hash_path(path_hash, "administration")
            )
        ),
        id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "ID"), min_len=1, max_len=2000
            )
        ),
        kind=(
            primitiving.choose_value(
                common.hash_path(path_hash, "kind"), list(aas_types.ModellingKind)
            )
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        submodel_elements=(
            [minimal_submodel_element(common.hash_path(path_hash, "submodel_elements"))]
        ),
    )


def maximal_submodel_element(path_hash: common.CanHash) -> aas_types.SubmodelElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Submodel_element"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.SubmodelElement,
    )
    return instance


def concrete_maximal_relationship_element(
    path_hash: common.CanHash,
) -> aas_types.RelationshipElement:
    """
    Generate a maximal instance based on the ``path_hash``.

    .. note::

        You usually do not call this function directly. It will be dispatched
        to.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.RelationshipElement(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        first=(minimal_reference(common.hash_path(path_hash, "first"))),
        second=(minimal_reference(common.hash_path(path_hash, "second"))),
    )


def maximal_relationship_element(
    path_hash: common.CanHash,
) -> aas_types.RelationshipElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS[
        "Relationship_element"
    ]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.RelationshipElement,
    )
    return instance


def maximal_submodel_element_list(
    path_hash: common.CanHash,
) -> aas_types.SubmodelElementList:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.SubmodelElementList(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        order_relevant=(
            primitiving.generate_bool(common.hash_path(path_hash, "order_relevant"))
        ),
        semantic_id_list_element=(
            minimal_reference(common.hash_path(path_hash, "semantic_ID_list_element"))
        ),
        type_value_list_element=(
            primitiving.choose_value(
                common.hash_path(path_hash, "type_value_list_element"),
                list(aas_types.AASSubmodelElements),
            )
        ),
        value_type_list_element=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type_list_element"),
                list(aas_types.DataTypeDefXSD),
            )
        ),
        value=([minimal_submodel_element(common.hash_path(path_hash, "value"))]),
    )


def maximal_submodel_element_collection(
    path_hash: common.CanHash,
) -> aas_types.SubmodelElementCollection:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.SubmodelElementCollection(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value=([minimal_submodel_element(common.hash_path(path_hash, "value"))]),
    )


def maximal_data_element(path_hash: common.CanHash) -> aas_types.DataElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Data_element"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.DataElement,
    )
    return instance


def maximal_property(path_hash: common.CanHash) -> aas_types.Property:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Property(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.choose_value(
                common.hash_path(path_hash, "category"),
                ["CONSTANT", "PARAMETER", "VARIABLE"],
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        ),
        value=(primitiving.generate_str(common.hash_path(path_hash, "value"))),
        value_id=(minimal_reference(common.hash_path(path_hash, "value_ID"))),
    )


def maximal_multi_language_property(
    path_hash: common.CanHash,
) -> aas_types.MultiLanguageProperty:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.MultiLanguageProperty(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.choose_value(
                common.hash_path(path_hash, "category"),
                ["CONSTANT", "PARAMETER", "VARIABLE"],
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value=([minimal_lang_string_text_type(common.hash_path(path_hash, "value"))]),
        value_id=(minimal_reference(common.hash_path(path_hash, "value_ID"))),
    )


def maximal_range(path_hash: common.CanHash) -> aas_types.Range:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Range(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.choose_value(
                common.hash_path(path_hash, "category"),
                ["CONSTANT", "PARAMETER", "VARIABLE"],
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "value_type"),
                list(aas_types.DataTypeDefXSD),
            )
        ),
        min=(primitiving.generate_str(common.hash_path(path_hash, "min"))),
        max=(primitiving.generate_str(common.hash_path(path_hash, "max"))),
    )


def maximal_reference_element(path_hash: common.CanHash) -> aas_types.ReferenceElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ReferenceElement(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.choose_value(
                common.hash_path(path_hash, "category"),
                ["CONSTANT", "PARAMETER", "VARIABLE"],
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value=(minimal_reference(common.hash_path(path_hash, "value"))),
    )


def maximal_blob(path_hash: common.CanHash) -> aas_types.Blob:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Blob(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.choose_value(
                common.hash_path(path_hash, "category"),
                ["CONSTANT", "PARAMETER", "VARIABLE"],
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value=(primitiving.generate_bytes(common.hash_path(path_hash, "value"))),
        content_type=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "content_type"),
                "^([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+|\"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*\"))*$",
            )
        ),
    )


def maximal_file(path_hash: common.CanHash) -> aas_types.File:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.File(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.choose_value(
                common.hash_path(path_hash, "category"),
                ["CONSTANT", "PARAMETER", "VARIABLE"],
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        value=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "value"),
                "^file:(//((localhost|(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){,6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)))?/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?)$",
            )
        ),
        content_type=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "content_type"),
                "^([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&'*+\\-.^_`|~0-9a-zA-Z])+|\"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*\"))*$",
            )
        ),
    )


def maximal_annotated_relationship_element(
    path_hash: common.CanHash,
) -> aas_types.AnnotatedRelationshipElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.AnnotatedRelationshipElement(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        first=(minimal_reference(common.hash_path(path_hash, "first"))),
        second=(minimal_reference(common.hash_path(path_hash, "second"))),
        annotations=(
            [minimal_data_element(common.hash_path(path_hash, "annotations"))]
        ),
    )


def maximal_entity(path_hash: common.CanHash) -> aas_types.Entity:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Entity(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        statements=(
            [minimal_submodel_element(common.hash_path(path_hash, "statements"))]
        ),
        entity_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "entity_type"), list(aas_types.EntityType)
            )
        ),
        global_asset_id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "global_asset_ID"), min_len=1, max_len=2000
            )
        ),
        specific_asset_ids=(
            [
                minimal_specific_asset_id(
                    common.hash_path(path_hash, "specific_asset_IDs")
                )
            ]
        ),
    )


def maximal_event_payload(path_hash: common.CanHash) -> aas_types.EventPayload:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.EventPayload(
        source=(minimal_reference(common.hash_path(path_hash, "source"))),
        source_semantic_id=(
            minimal_reference(common.hash_path(path_hash, "source_semantic_ID"))
        ),
        observable_reference=(
            minimal_reference(common.hash_path(path_hash, "observable_reference"))
        ),
        observable_semantic_id=(
            minimal_reference(common.hash_path(path_hash, "observable_semantic_ID"))
        ),
        topic=(
            primitiving.generate_str(
                common.hash_path(path_hash, "topic"), min_len=1, max_len=255
            )
        ),
        subject_id=(minimal_reference(common.hash_path(path_hash, "subject_ID"))),
        time_stamp=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "time_stamp"),
                "^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|\\+00:00|-00:00)$",
            )
        ),
        payload=(primitiving.generate_bytes(common.hash_path(path_hash, "payload"))),
    )


def maximal_event_element(path_hash: common.CanHash) -> aas_types.EventElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS["Event_element"]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.EventElement,
    )
    return instance


def maximal_basic_event_element(
    path_hash: common.CanHash,
) -> aas_types.BasicEventElement:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.BasicEventElement(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        observed=(minimal_reference(common.hash_path(path_hash, "observed"))),
        direction=(
            primitiving.choose_value(
                common.hash_path(path_hash, "direction"), list(aas_types.Direction)
            )
        ),
        state=(
            primitiving.choose_value(
                common.hash_path(path_hash, "state"), list(aas_types.StateOfEvent)
            )
        ),
        message_topic=(
            primitiving.generate_str(
                common.hash_path(path_hash, "message_topic"), min_len=1, max_len=255
            )
        ),
        message_broker=(
            minimal_reference(common.hash_path(path_hash, "message_broker"))
        ),
        last_update=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "last_update"),
                "^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|\\+00:00|-00:00)$",
            )
        ),
        min_interval=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "min_interval"),
                "^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$",
            )
        ),
        max_interval=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "max_interval"),
                "^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$",
            )
        ),
    )


def maximal_operation(path_hash: common.CanHash) -> aas_types.Operation:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Operation(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        input_variables=(
            [minimal_operation_variable(common.hash_path(path_hash, "input_variables"))]
        ),
        output_variables=(
            [
                minimal_operation_variable(
                    common.hash_path(path_hash, "output_variables")
                )
            ]
        ),
        inoutput_variables=(
            [
                minimal_operation_variable(
                    common.hash_path(path_hash, "inoutput_variables")
                )
            ]
        ),
    )


def maximal_operation_variable(
    path_hash: common.CanHash,
) -> aas_types.OperationVariable:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.OperationVariable(
        value=(minimal_submodel_element(common.hash_path(path_hash, "value")))
    )


def maximal_capability(path_hash: common.CanHash) -> aas_types.Capability:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Capability(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        semantic_id=(minimal_reference(common.hash_path(path_hash, "semantic_ID"))),
        supplemental_semantic_ids=(
            [
                minimal_reference(
                    common.hash_path(path_hash, "supplemental_semantic_IDs")
                )
            ]
        ),
        qualifiers=([minimal_qualifier(common.hash_path(path_hash, "qualifiers"))]),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
    )


def maximal_concept_description(
    path_hash: common.CanHash,
) -> aas_types.ConceptDescription:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ConceptDescription(
        extensions=([minimal_extension(common.hash_path(path_hash, "extensions"))]),
        category=(
            primitiving.generate_str(
                common.hash_path(path_hash, "category"), min_len=1, max_len=128
            )
        ),
        id_short=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "ID_short"), "^[a-zA-Z][a-zA-Z0-9_]*$"
            )
        ),
        display_name=(
            [minimal_lang_string_name_type(common.hash_path(path_hash, "display_name"))]
        ),
        description=(
            [minimal_lang_string_text_type(common.hash_path(path_hash, "description"))]
        ),
        administration=(
            minimal_administrative_information(
                common.hash_path(path_hash, "administration")
            )
        ),
        id=(
            primitiving.generate_str(
                common.hash_path(path_hash, "ID"), min_len=1, max_len=2000
            )
        ),
        embedded_data_specifications=(
            [
                minimal_embedded_data_specification(
                    common.hash_path(path_hash, "embedded_data_specifications")
                )
            ]
        ),
        is_case_of=([minimal_reference(common.hash_path(path_hash, "is_case_of"))]),
    )


def maximal_reference(path_hash: common.CanHash) -> aas_types.Reference:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Reference(
        type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "type"), list(aas_types.ReferenceTypes)
            )
        ),
        referred_semantic_id=(
            minimal_reference(common.hash_path(path_hash, "referred_semantic_ID"))
        ),
        keys=([minimal_key(common.hash_path(path_hash, "keys"))]),
    )


def maximal_key(path_hash: common.CanHash) -> aas_types.Key:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Key(
        type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "type"), list(aas_types.KeyTypes)
            )
        ),
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
    )


def maximal_abstract_lang_string(
    path_hash: common.CanHash,
) -> aas_types.AbstractLangString:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS[
        "Abstract_lang_string"
    ]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.AbstractLangString,
    )
    return instance


def maximal_lang_string_name_type(
    path_hash: common.CanHash,
) -> aas_types.LangStringNameType:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringNameType(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=128
            )
        ),
    )


def maximal_lang_string_text_type(
    path_hash: common.CanHash,
) -> aas_types.LangStringTextType:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringTextType(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=1023
            )
        ),
    )


def maximal_environment(path_hash: common.CanHash) -> aas_types.Environment:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.Environment(
        asset_administration_shells=(
            [
                minimal_asset_administration_shell(
                    common.hash_path(path_hash, "asset_administration_shells")
                )
            ]
        ),
        submodels=([minimal_submodel(common.hash_path(path_hash, "submodels"))]),
        concept_descriptions=(
            [
                minimal_concept_description(
                    common.hash_path(path_hash, "concept_descriptions")
                )
            ]
        ),
    )


def maximal_data_specification_content(
    path_hash: common.CanHash,
) -> aas_types.DataSpecificationContent:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    number = int(path_hash.hexdigest()[:8], base=16)
    concrete_maximal_functions = _CLASS_NAME_TO_CONCRETE_MAXIMALS[
        "Data_specification_content"
    ]
    concrete_maximal_function = concrete_maximal_functions[
        number % len(concrete_maximal_functions)
    ]
    instance = concrete_maximal_function(path_hash)
    assert isinstance(
        instance,
        aas_types.DataSpecificationContent,
    )
    return instance


def maximal_embedded_data_specification(
    path_hash: common.CanHash,
) -> aas_types.EmbeddedDataSpecification:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.EmbeddedDataSpecification(
        data_specification=(
            minimal_reference(common.hash_path(path_hash, "data_specification"))
        ),
        data_specification_content=(
            minimal_data_specification_content(
                common.hash_path(path_hash, "data_specification_content")
            )
        ),
    )


def maximal_level_type(path_hash: common.CanHash) -> aas_types.LevelType:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LevelType(
        min=(primitiving.generate_bool(common.hash_path(path_hash, "min"))),
        nom=(primitiving.generate_bool(common.hash_path(path_hash, "nom"))),
        typ=(primitiving.generate_bool(common.hash_path(path_hash, "typ"))),
        max=(primitiving.generate_bool(common.hash_path(path_hash, "max"))),
    )


def maximal_value_reference_pair(
    path_hash: common.CanHash,
) -> aas_types.ValueReferencePair:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ValueReferencePair(
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
        value_id=(minimal_reference(common.hash_path(path_hash, "value_ID"))),
    )


def maximal_value_list(path_hash: common.CanHash) -> aas_types.ValueList:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.ValueList(
        value_reference_pairs=(
            [
                minimal_value_reference_pair(
                    common.hash_path(path_hash, "value_reference_pairs")
                )
            ]
        )
    )


def maximal_lang_string_preferred_name_type_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.LangStringPreferredNameTypeIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringPreferredNameTypeIEC61360(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=255
            )
        ),
    )


def maximal_lang_string_short_name_type_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.LangStringShortNameTypeIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringShortNameTypeIEC61360(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=18
            )
        ),
    )


def maximal_lang_string_definition_type_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.LangStringDefinitionTypeIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.LangStringDefinitionTypeIEC61360(
        language=(
            primitiving.generate_str_satisfying_pattern(
                common.hash_path(path_hash, "language"),
                "^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){,2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$",
            )
        ),
        text=(
            primitiving.generate_str(
                common.hash_path(path_hash, "text"), min_len=1, max_len=1023
            )
        ),
    )


def maximal_data_specification_iec_61360(
    path_hash: common.CanHash,
) -> aas_types.DataSpecificationIEC61360:
    """
    Generate a minimal instance based on the ``path_hash``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    return aas_types.DataSpecificationIEC61360(
        preferred_name=(
            [
                minimal_lang_string_preferred_name_type_iec_61360(
                    common.hash_path(path_hash, "preferred_name")
                )
            ]
        ),
        short_name=(
            [
                minimal_lang_string_short_name_type_iec_61360(
                    common.hash_path(path_hash, "short_name")
                )
            ]
        ),
        unit=(
            primitiving.generate_str(
                common.hash_path(path_hash, "unit"), min_len=1, max_len=None
            )
        ),
        unit_id=(minimal_reference(common.hash_path(path_hash, "unit_ID"))),
        source_of_definition=(
            primitiving.generate_str(
                common.hash_path(path_hash, "source_of_definition"),
                min_len=1,
                max_len=None,
            )
        ),
        symbol=(
            primitiving.generate_str(
                common.hash_path(path_hash, "symbol"), min_len=1, max_len=None
            )
        ),
        data_type=(
            primitiving.choose_value(
                common.hash_path(path_hash, "data_type"),
                list(aas_types.DataTypeIEC61360),
            )
        ),
        definition=(
            [
                minimal_lang_string_definition_type_iec_61360(
                    common.hash_path(path_hash, "definition")
                )
            ]
        ),
        value_format=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value_format"), min_len=1, max_len=None
            )
        ),
        value_list=(minimal_value_list(common.hash_path(path_hash, "value_list"))),
        value=(
            primitiving.generate_str(
                common.hash_path(path_hash, "value"), min_len=1, max_len=2000
            )
        ),
        level_type=(minimal_level_type(common.hash_path(path_hash, "level_type"))),
    )


_CLASS_NAME_TO_CONCRETE_MAXIMALS = {
    "Has_semantics": [
        maximal_relationship_element,
        maximal_annotated_relationship_element,
        maximal_basic_event_element,
        maximal_blob,
        maximal_capability,
        maximal_entity,
        maximal_extension,
        maximal_file,
        maximal_multi_language_property,
        maximal_operation,
        maximal_property,
        maximal_qualifier,
        maximal_range,
        maximal_reference_element,
        maximal_specific_asset_id,
        maximal_submodel,
        maximal_submodel_element_collection,
        maximal_submodel_element_list,
    ],
    "Has_extensions": [
        maximal_relationship_element,
        maximal_annotated_relationship_element,
        maximal_asset_administration_shell,
        maximal_basic_event_element,
        maximal_blob,
        maximal_capability,
        maximal_concept_description,
        maximal_entity,
        maximal_file,
        maximal_multi_language_property,
        maximal_operation,
        maximal_property,
        maximal_range,
        maximal_reference_element,
        maximal_submodel,
        maximal_submodel_element_collection,
        maximal_submodel_element_list,
    ],
    "Referable": [
        maximal_relationship_element,
        maximal_annotated_relationship_element,
        maximal_asset_administration_shell,
        maximal_basic_event_element,
        maximal_blob,
        maximal_capability,
        maximal_concept_description,
        maximal_entity,
        maximal_file,
        maximal_multi_language_property,
        maximal_operation,
        maximal_property,
        maximal_range,
        maximal_reference_element,
        maximal_submodel,
        maximal_submodel_element_collection,
        maximal_submodel_element_list,
    ],
    "Identifiable": [
        maximal_asset_administration_shell,
        maximal_concept_description,
        maximal_submodel,
    ],
    "Has_kind": [maximal_submodel],
    "Has_data_specification": [
        maximal_administrative_information,
        maximal_relationship_element,
        maximal_annotated_relationship_element,
        maximal_asset_administration_shell,
        maximal_basic_event_element,
        maximal_blob,
        maximal_capability,
        maximal_concept_description,
        maximal_entity,
        maximal_file,
        maximal_multi_language_property,
        maximal_operation,
        maximal_property,
        maximal_range,
        maximal_reference_element,
        maximal_submodel,
        maximal_submodel_element_collection,
        maximal_submodel_element_list,
    ],
    "Qualifiable": [
        maximal_relationship_element,
        maximal_annotated_relationship_element,
        maximal_basic_event_element,
        maximal_blob,
        maximal_capability,
        maximal_entity,
        maximal_file,
        maximal_multi_language_property,
        maximal_operation,
        maximal_property,
        maximal_range,
        maximal_reference_element,
        maximal_submodel,
        maximal_submodel_element_collection,
        maximal_submodel_element_list,
    ],
    "Submodel_element": [
        maximal_relationship_element,
        maximal_annotated_relationship_element,
        maximal_basic_event_element,
        maximal_blob,
        maximal_capability,
        maximal_entity,
        maximal_file,
        maximal_multi_language_property,
        maximal_operation,
        maximal_property,
        maximal_range,
        maximal_reference_element,
        maximal_submodel_element_collection,
        maximal_submodel_element_list,
    ],
    "Relationship_element": [
        concrete_maximal_relationship_element,
        maximal_annotated_relationship_element,
    ],
    "Data_element": [
        maximal_blob,
        maximal_file,
        maximal_multi_language_property,
        maximal_property,
        maximal_range,
        maximal_reference_element,
    ],
    "Event_element": [maximal_basic_event_element],
    "Abstract_lang_string": [
        maximal_lang_string_definition_type_iec_61360,
        maximal_lang_string_name_type,
        maximal_lang_string_preferred_name_type_iec_61360,
        maximal_lang_string_short_name_type_iec_61360,
        maximal_lang_string_text_type,
    ],
    "Data_specification_content": [maximal_data_specification_iec_61360],
}  # type: Mapping[str, Sequence[Callable[[common.CanHash], aas_types.Class]]]


_CLASS_NAME_TO_EXACT_CONCRETE_MAXIMAL = {
    "Extension": maximal_extension,
    "Administrative_information": maximal_administrative_information,
    "Qualifier": maximal_qualifier,
    "Asset_administration_shell": maximal_asset_administration_shell,
    "Asset_information": maximal_asset_information,
    "Resource": maximal_resource,
    "Specific_asset_ID": maximal_specific_asset_id,
    "Submodel": maximal_submodel,
    "Relationship_element": concrete_maximal_relationship_element,
    "Submodel_element_list": maximal_submodel_element_list,
    "Submodel_element_collection": maximal_submodel_element_collection,
    "Property": maximal_property,
    "Multi_language_property": maximal_multi_language_property,
    "Range": maximal_range,
    "Reference_element": maximal_reference_element,
    "Blob": maximal_blob,
    "File": maximal_file,
    "Annotated_relationship_element": maximal_annotated_relationship_element,
    "Entity": maximal_entity,
    "Event_payload": maximal_event_payload,
    "Basic_event_element": maximal_basic_event_element,
    "Operation": maximal_operation,
    "Operation_variable": maximal_operation_variable,
    "Capability": maximal_capability,
    "Concept_description": maximal_concept_description,
    "Reference": maximal_reference,
    "Key": maximal_key,
    "Lang_string_name_type": maximal_lang_string_name_type,
    "Lang_string_text_type": maximal_lang_string_text_type,
    "Environment": maximal_environment,
    "Embedded_data_specification": maximal_embedded_data_specification,
    "Level_type": maximal_level_type,
    "Value_reference_pair": maximal_value_reference_pair,
    "Value_list": maximal_value_list,
    "Lang_string_preferred_name_type_IEC_61360": maximal_lang_string_preferred_name_type_iec_61360,
    "Lang_string_short_name_type_IEC_61360": maximal_lang_string_short_name_type_iec_61360,
    "Lang_string_definition_type_IEC_61360": maximal_lang_string_definition_type_iec_61360,
    "Data_specification_IEC_61360": maximal_data_specification_iec_61360,
}


def exact_concrete_maximal(
    path_hash: common.CanHash, class_name: str
) -> aas_types.Class:
    """
    Create a maximal instance of exactly ``class_name``.

    .. note::

        The generated instance satisfies only the type constraints.
        That means it can be serialized as-is, but probably violates one or
        more meta-model constraints.
    """
    dispatch = _CLASS_NAME_TO_EXACT_CONCRETE_MAXIMAL.get(class_name, None)
    if dispatch is None:
        raise KeyError(
            f"The class name {class_name!r} does not denote a concrete class "
            f"in the meta-model. Did you spell its name in the format of "
            f"aas-core-meta (*not* Python)?"
        )
    return dispatch(path_hash)


# Automatically generated by dev_scripts/codegen/generate_creation.py.
# Do NOT edit or append!

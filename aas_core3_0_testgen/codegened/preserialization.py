"""Pre-serialize the instances for further modification."""


# Automatically generated by dev_scripts/codegen/generate_preserialization.py.
# Do NOT edit or append!


import collections
import json
from typing import (
    Any,
    get_args,
    List,
    MutableMapping,
    Optional,
    OrderedDict,
    Tuple,
    Union,
)

from aas_core_codegen.common import Identifier, assert_never

from aas_core3 import types as aas_types


PrimitiveValueUnion = Union[bool, int, float, str, bytes]


PrimitiveValueTuple = (bool, int, float, str, bytes)
assert PrimitiveValueTuple == get_args(PrimitiveValueUnion)


ValueUnion = Union[PrimitiveValueUnion, "Instance", "ListOfInstances"]


class Instance:
    """Represent an instance of a class."""

    #: Pre-serialized properties of the instance.
    #:
    #: Our default pre-serialization is to *omit* properties which are set to ``None``.
    #: However, there are test cases where we explicitly want to test handling of
    #: ``null`` JSON values. We leave it therefore open for the downstream client
    #: to define properties as ``null`` (by setting them to ``None``) even though
    #: our pre-serializer simply omits them.
    properties: OrderedDict[str, Optional[ValueUnion]]

    #: Class name according to aas-core-meta format, *not* as a Python class
    class_name: Identifier

    def __init__(
        self, properties: OrderedDict[str, Optional[ValueUnion]], class_name: Identifier
    ) -> None:
        """
        Initialize with the given values.

        The ``class_name`` needs to be always indicated. It is written in aas-core-meta
        format, *not* as the Python class name.
        """
        self.properties = properties
        self.class_name = class_name


class ListOfInstances:
    """Represent a list of instances."""

    def __init__(self, values: List[Instance]) -> None:
        """Initialize with the given values."""
        self.values = values


def _to_jsonable(value: Optional[ValueUnion]) -> Any:
    """
    Represent the ``value`` as a JSON-able object.

    This is meant for debugging, not for the end-user serialization.
    """
    if value is None:
        return None

    if isinstance(value, PrimitiveValueTuple):
        if isinstance(value, bytes):
            return repr(value)
        else:
            return value
    elif isinstance(value, Instance):
        obj = collections.OrderedDict()  # type: MutableMapping[str, Any]
        obj["class_name"] = value.class_name

        properties_dict = collections.OrderedDict()  # type: MutableMapping[str, Any]
        for prop_name, prop_value in value.properties.items():
            properties_dict[prop_name] = _to_jsonable(prop_value)

        obj["properties"] = properties_dict

        return obj
    elif isinstance(value, ListOfInstances):
        return [_to_jsonable(item) for item in value.values]
    else:
        assert_never(value)


def dump(value: ValueUnion) -> str:
    """
    Represent the ``value`` as a string.

    This is meant for debugging, not for the end-user serialization.
    """
    return json.dumps(_to_jsonable(value), indent=2)


class _Preserializer(aas_types.AbstractTransformer[Instance]):
    """Transform instances to a pre-serialized representation."""

    def __init__(self) -> None:
        """Initialize empty."""
        self.instance_to_preserialized = (
            dict()
        )  # type: MutableMapping[aas_types.Class, Instance]

    def transform_extension(self, that: aas_types.Extension) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        properties["name"] = that.name

        if that.value_type is not None:
            properties["value_type"] = that.value_type.value

        if that.value is not None:
            properties["value"] = that.value

        if that.refers_to is not None:
            properties["refers_to"] = ListOfInstances(
                [self.transform(item) for item in that.refers_to]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Extension")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_administrative_information(
        self, that: aas_types.AdministrativeInformation
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.version is not None:
            properties["version"] = that.version

        if that.revision is not None:
            properties["revision"] = that.revision

        if that.creator is not None:
            properties["creator"] = self.transform(that.creator)

        if that.template_id is not None:
            properties["template_ID"] = that.template_id

        preserialized = Instance(
            properties=properties, class_name=Identifier("Administrative_information")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_qualifier(self, that: aas_types.Qualifier) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.kind is not None:
            properties["kind"] = that.kind.value

        properties["type"] = that.type

        properties["value_type"] = that.value_type.value

        if that.value is not None:
            properties["value"] = that.value

        if that.value_id is not None:
            properties["value_ID"] = self.transform(that.value_id)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Qualifier")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_asset_administration_shell(
        self, that: aas_types.AssetAdministrationShell
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.administration is not None:
            properties["administration"] = self.transform(that.administration)

        properties["ID"] = that.id

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.derived_from is not None:
            properties["derived_from"] = self.transform(that.derived_from)

        properties["asset_information"] = self.transform(that.asset_information)

        if that.submodels is not None:
            properties["submodels"] = ListOfInstances(
                [self.transform(item) for item in that.submodels]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Asset_administration_shell")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_asset_information(self, that: aas_types.AssetInformation) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["asset_kind"] = that.asset_kind.value

        if that.global_asset_id is not None:
            properties["global_asset_ID"] = that.global_asset_id

        if that.specific_asset_ids is not None:
            properties["specific_asset_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.specific_asset_ids]
            )

        if that.asset_type is not None:
            properties["asset_type"] = that.asset_type

        if that.default_thumbnail is not None:
            properties["default_thumbnail"] = self.transform(that.default_thumbnail)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Asset_information")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_resource(self, that: aas_types.Resource) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["path"] = that.path

        if that.content_type is not None:
            properties["content_type"] = that.content_type

        preserialized = Instance(
            properties=properties, class_name=Identifier("Resource")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_specific_asset_id(self, that: aas_types.SpecificAssetID) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        properties["name"] = that.name

        properties["value"] = that.value

        if that.external_subject_id is not None:
            properties["external_subject_ID"] = self.transform(that.external_subject_id)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Specific_asset_ID")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_submodel(self, that: aas_types.Submodel) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.administration is not None:
            properties["administration"] = self.transform(that.administration)

        properties["ID"] = that.id

        if that.kind is not None:
            properties["kind"] = that.kind.value

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.submodel_elements is not None:
            properties["submodel_elements"] = ListOfInstances(
                [self.transform(item) for item in that.submodel_elements]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Submodel")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_relationship_element(
        self, that: aas_types.RelationshipElement
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        properties["first"] = self.transform(that.first)

        properties["second"] = self.transform(that.second)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Relationship_element")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_submodel_element_list(
        self, that: aas_types.SubmodelElementList
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.order_relevant is not None:
            properties["order_relevant"] = that.order_relevant

        if that.semantic_id_list_element is not None:
            properties["semantic_ID_list_element"] = self.transform(
                that.semantic_id_list_element
            )

        properties["type_value_list_element"] = that.type_value_list_element.value

        if that.value_type_list_element is not None:
            properties["value_type_list_element"] = that.value_type_list_element.value

        if that.value is not None:
            properties["value"] = ListOfInstances(
                [self.transform(item) for item in that.value]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Submodel_element_list")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_submodel_element_collection(
        self, that: aas_types.SubmodelElementCollection
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.value is not None:
            properties["value"] = ListOfInstances(
                [self.transform(item) for item in that.value]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Submodel_element_collection")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_property(self, that: aas_types.Property) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        properties["value_type"] = that.value_type.value

        if that.value is not None:
            properties["value"] = that.value

        if that.value_id is not None:
            properties["value_ID"] = self.transform(that.value_id)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Property")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_multi_language_property(
        self, that: aas_types.MultiLanguageProperty
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.value is not None:
            properties["value"] = ListOfInstances(
                [self.transform(item) for item in that.value]
            )

        if that.value_id is not None:
            properties["value_ID"] = self.transform(that.value_id)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Multi_language_property")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_range(self, that: aas_types.Range) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        properties["value_type"] = that.value_type.value

        if that.min is not None:
            properties["min"] = that.min

        if that.max is not None:
            properties["max"] = that.max

        preserialized = Instance(properties=properties, class_name=Identifier("Range"))
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_reference_element(self, that: aas_types.ReferenceElement) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.value is not None:
            properties["value"] = self.transform(that.value)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Reference_element")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_blob(self, that: aas_types.Blob) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.value is not None:
            properties["value"] = that.value

        properties["content_type"] = that.content_type

        preserialized = Instance(properties=properties, class_name=Identifier("Blob"))
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_file(self, that: aas_types.File) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.value is not None:
            properties["value"] = that.value

        properties["content_type"] = that.content_type

        preserialized = Instance(properties=properties, class_name=Identifier("File"))
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_annotated_relationship_element(
        self, that: aas_types.AnnotatedRelationshipElement
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        properties["first"] = self.transform(that.first)

        properties["second"] = self.transform(that.second)

        if that.annotations is not None:
            properties["annotations"] = ListOfInstances(
                [self.transform(item) for item in that.annotations]
            )

        preserialized = Instance(
            properties=properties,
            class_name=Identifier("Annotated_relationship_element"),
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_entity(self, that: aas_types.Entity) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.statements is not None:
            properties["statements"] = ListOfInstances(
                [self.transform(item) for item in that.statements]
            )

        properties["entity_type"] = that.entity_type.value

        if that.global_asset_id is not None:
            properties["global_asset_ID"] = that.global_asset_id

        if that.specific_asset_ids is not None:
            properties["specific_asset_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.specific_asset_ids]
            )

        preserialized = Instance(properties=properties, class_name=Identifier("Entity"))
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_event_payload(self, that: aas_types.EventPayload) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["source"] = self.transform(that.source)

        if that.source_semantic_id is not None:
            properties["source_semantic_ID"] = self.transform(that.source_semantic_id)

        properties["observable_reference"] = self.transform(that.observable_reference)

        if that.observable_semantic_id is not None:
            properties["observable_semantic_ID"] = self.transform(
                that.observable_semantic_id
            )

        if that.topic is not None:
            properties["topic"] = that.topic

        if that.subject_id is not None:
            properties["subject_ID"] = self.transform(that.subject_id)

        properties["time_stamp"] = that.time_stamp

        if that.payload is not None:
            properties["payload"] = that.payload

        preserialized = Instance(
            properties=properties, class_name=Identifier("Event_payload")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_basic_event_element(
        self, that: aas_types.BasicEventElement
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        properties["observed"] = self.transform(that.observed)

        properties["direction"] = that.direction.value

        properties["state"] = that.state.value

        if that.message_topic is not None:
            properties["message_topic"] = that.message_topic

        if that.message_broker is not None:
            properties["message_broker"] = self.transform(that.message_broker)

        if that.last_update is not None:
            properties["last_update"] = that.last_update

        if that.min_interval is not None:
            properties["min_interval"] = that.min_interval

        if that.max_interval is not None:
            properties["max_interval"] = that.max_interval

        preserialized = Instance(
            properties=properties, class_name=Identifier("Basic_event_element")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_operation(self, that: aas_types.Operation) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.input_variables is not None:
            properties["input_variables"] = ListOfInstances(
                [self.transform(item) for item in that.input_variables]
            )

        if that.output_variables is not None:
            properties["output_variables"] = ListOfInstances(
                [self.transform(item) for item in that.output_variables]
            )

        if that.inoutput_variables is not None:
            properties["inoutput_variables"] = ListOfInstances(
                [self.transform(item) for item in that.inoutput_variables]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Operation")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_operation_variable(
        self, that: aas_types.OperationVariable
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["value"] = self.transform(that.value)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Operation_variable")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_capability(self, that: aas_types.Capability) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.semantic_id is not None:
            properties["semantic_ID"] = self.transform(that.semantic_id)

        if that.supplemental_semantic_ids is not None:
            properties["supplemental_semantic_IDs"] = ListOfInstances(
                [self.transform(item) for item in that.supplemental_semantic_ids]
            )

        if that.qualifiers is not None:
            properties["qualifiers"] = ListOfInstances(
                [self.transform(item) for item in that.qualifiers]
            )

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Capability")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_concept_description(
        self, that: aas_types.ConceptDescription
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.extensions is not None:
            properties["extensions"] = ListOfInstances(
                [self.transform(item) for item in that.extensions]
            )

        if that.category is not None:
            properties["category"] = that.category

        if that.id_short is not None:
            properties["ID_short"] = that.id_short

        if that.display_name is not None:
            properties["display_name"] = ListOfInstances(
                [self.transform(item) for item in that.display_name]
            )

        if that.description is not None:
            properties["description"] = ListOfInstances(
                [self.transform(item) for item in that.description]
            )

        if that.administration is not None:
            properties["administration"] = self.transform(that.administration)

        properties["ID"] = that.id

        if that.embedded_data_specifications is not None:
            properties["embedded_data_specifications"] = ListOfInstances(
                [self.transform(item) for item in that.embedded_data_specifications]
            )

        if that.is_case_of is not None:
            properties["is_case_of"] = ListOfInstances(
                [self.transform(item) for item in that.is_case_of]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Concept_description")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_reference(self, that: aas_types.Reference) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["type"] = that.type.value

        if that.referred_semantic_id is not None:
            properties["referred_semantic_ID"] = self.transform(
                that.referred_semantic_id
            )

        properties["keys"] = ListOfInstances(
            [self.transform(item) for item in that.keys]
        )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Reference")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_key(self, that: aas_types.Key) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["type"] = that.type.value

        properties["value"] = that.value

        preserialized = Instance(properties=properties, class_name=Identifier("Key"))
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_lang_string_name_type(
        self, that: aas_types.LangStringNameType
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["language"] = that.language

        properties["text"] = that.text

        preserialized = Instance(
            properties=properties, class_name=Identifier("Lang_string_name_type")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_lang_string_text_type(
        self, that: aas_types.LangStringTextType
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["language"] = that.language

        properties["text"] = that.text

        preserialized = Instance(
            properties=properties, class_name=Identifier("Lang_string_text_type")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_environment(self, that: aas_types.Environment) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        if that.asset_administration_shells is not None:
            properties["asset_administration_shells"] = ListOfInstances(
                [self.transform(item) for item in that.asset_administration_shells]
            )

        if that.submodels is not None:
            properties["submodels"] = ListOfInstances(
                [self.transform(item) for item in that.submodels]
            )

        if that.concept_descriptions is not None:
            properties["concept_descriptions"] = ListOfInstances(
                [self.transform(item) for item in that.concept_descriptions]
            )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Environment")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_embedded_data_specification(
        self, that: aas_types.EmbeddedDataSpecification
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["data_specification_content"] = self.transform(
            that.data_specification_content
        )

        if that.data_specification is not None:
            properties["data_specification"] = self.transform(that.data_specification)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Embedded_data_specification")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_level_type(self, that: aas_types.LevelType) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["min"] = that.min

        properties["nom"] = that.nom

        properties["typ"] = that.typ

        properties["max"] = that.max

        preserialized = Instance(
            properties=properties, class_name=Identifier("Level_type")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_value_reference_pair(
        self, that: aas_types.ValueReferencePair
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["value"] = that.value

        properties["value_ID"] = self.transform(that.value_id)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Value_reference_pair")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_value_list(self, that: aas_types.ValueList) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["value_reference_pairs"] = ListOfInstances(
            [self.transform(item) for item in that.value_reference_pairs]
        )

        preserialized = Instance(
            properties=properties, class_name=Identifier("Value_list")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_lang_string_preferred_name_type_iec_61360(
        self, that: aas_types.LangStringPreferredNameTypeIEC61360
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["language"] = that.language

        properties["text"] = that.text

        preserialized = Instance(
            properties=properties,
            class_name=Identifier("Lang_string_preferred_name_type_IEC_61360"),
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_lang_string_short_name_type_iec_61360(
        self, that: aas_types.LangStringShortNameTypeIEC61360
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["language"] = that.language

        properties["text"] = that.text

        preserialized = Instance(
            properties=properties,
            class_name=Identifier("Lang_string_short_name_type_IEC_61360"),
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_lang_string_definition_type_iec_61360(
        self, that: aas_types.LangStringDefinitionTypeIEC61360
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["language"] = that.language

        properties["text"] = that.text

        preserialized = Instance(
            properties=properties,
            class_name=Identifier("Lang_string_definition_type_IEC_61360"),
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized

    def transform_data_specification_iec_61360(
        self, that: aas_types.DataSpecificationIEC61360
    ) -> Instance:
        properties = (
            collections.OrderedDict()
        )  # type: OrderedDict[str, Optional[ValueUnion]]

        properties["preferred_name"] = ListOfInstances(
            [self.transform(item) for item in that.preferred_name]
        )

        if that.short_name is not None:
            properties["short_name"] = ListOfInstances(
                [self.transform(item) for item in that.short_name]
            )

        if that.unit is not None:
            properties["unit"] = that.unit

        if that.unit_id is not None:
            properties["unit_ID"] = self.transform(that.unit_id)

        if that.source_of_definition is not None:
            properties["source_of_definition"] = that.source_of_definition

        if that.symbol is not None:
            properties["symbol"] = that.symbol

        if that.data_type is not None:
            properties["data_type"] = that.data_type.value

        if that.definition is not None:
            properties["definition"] = ListOfInstances(
                [self.transform(item) for item in that.definition]
            )

        if that.value_format is not None:
            properties["value_format"] = that.value_format

        if that.value_list is not None:
            properties["value_list"] = self.transform(that.value_list)

        if that.value is not None:
            properties["value"] = that.value

        if that.level_type is not None:
            properties["level_type"] = self.transform(that.level_type)

        preserialized = Instance(
            properties=properties, class_name=Identifier("Data_specification_IEC_61360")
        )
        self.instance_to_preserialized[that] = preserialized
        return preserialized


_PRESERIALIZER = _Preserializer()


def preserialize(
    that: aas_types.Class,
) -> Tuple[Instance, MutableMapping[aas_types.Class, Instance]]:
    """
    Pre-serialize ``that`` instance for further modification.

    Return the pre-serialization together with
    the map model instance 🠒 pre-serialized instance.
    """
    preserializer = _Preserializer()
    preserialized = preserializer.transform(that)
    return preserialized, preserializer.instance_to_preserialized


# Automatically generated by dev_scripts/codegen/generate_preserialization.py.
# Do NOT edit or append!
